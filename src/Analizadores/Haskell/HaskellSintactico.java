
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package Analizadores.Haskell;

import Analizadores.Errores;
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import Dibujar.Nodo;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class HaskellSintactico extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return SimbolosHaskell.class;
}

  /** Default constructor. */
  @Deprecated
  public HaskellSintactico() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public HaskellSintactico(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public HaskellSintactico(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\177\000\002\002\004\000\002\053\002\000\002\002" +
    "\004\000\002\005\004\000\002\005\003\000\002\006\007" +
    "\000\002\014\003\000\002\014\002\000\002\004\005\000" +
    "\002\004\003\000\002\003\003\000\002\003\003\000\002" +
    "\011\004\000\002\011\003\000\002\012\003\000\002\012" +
    "\003\000\002\012\003\000\002\027\011\000\002\030\006" +
    "\000\002\031\004\000\002\031\003\000\002\032\006\000" +
    "\002\022\003\000\002\022\003\000\002\007\003\000\002" +
    "\007\003\000\002\007\003\000\002\007\003\000\002\007" +
    "\003\000\002\007\003\000\002\007\003\000\002\007\003" +
    "\000\002\007\003\000\002\007\003\000\002\007\003\000" +
    "\002\007\003\000\002\007\003\000\002\007\003\000\002" +
    "\007\003\000\002\007\003\000\002\007\003\000\002\015" +
    "\010\000\002\024\006\000\002\033\006\000\002\034\006" +
    "\000\002\035\006\000\002\036\006\000\002\037\003\000" +
    "\002\037\003\000\002\041\006\000\002\042\006\000\002" +
    "\043\006\000\002\044\006\000\002\045\006\000\002\046" +
    "\006\000\002\047\006\000\002\050\006\000\002\051\005" +
    "\000\002\051\003\000\002\040\003\000\002\040\003\000" +
    "\002\040\003\000\002\052\006\000\002\026\004\000\002" +
    "\026\002\000\002\025\005\000\002\025\005\000\002\025" +
    "\005\000\002\025\005\000\002\025\005\000\002\025\005" +
    "\000\002\025\005\000\002\025\003\000\002\025\003\000" +
    "\002\025\003\000\002\025\004\000\002\025\005\000\002" +
    "\025\003\000\002\025\003\000\002\025\003\000\002\025" +
    "\003\000\002\025\003\000\002\025\003\000\002\025\003" +
    "\000\002\025\003\000\002\025\003\000\002\025\003\000" +
    "\002\016\005\000\002\017\003\000\002\017\003\000\002" +
    "\021\005\000\002\021\003\000\002\020\005\000\002\020" +
    "\003\000\002\013\005\000\002\023\005\000\002\023\005" +
    "\000\002\023\005\000\002\023\005\000\002\023\005\000" +
    "\002\023\005\000\002\023\005\000\002\023\005\000\002" +
    "\023\005\000\002\023\005\000\002\023\005\000\002\023" +
    "\005\000\002\023\005\000\002\023\005\000\002\023\005" +
    "\000\002\023\003\000\002\023\003\000\002\023\003\000" +
    "\002\023\004\000\002\023\005\000\002\023\003\000\002" +
    "\023\003\000\002\023\003\000\002\023\003\000\002\023" +
    "\003\000\002\023\003\000\002\023\003\000\002\023\003" +
    "\000\002\023\003\000\002\023\003\000\002\023\003\000" +
    "\002\010\010" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\333\000\004\066\000\001\002\000\004\066\011\001" +
    "\002\000\004\002\006\001\002\000\004\002\001\001\002" +
    "\000\006\002\ufffd\066\ufffd\001\002\000\006\002\uffff\066" +
    "\011\001\002\000\024\005\022\023\ufffa\024\023\032\025" +
    "\036\032\063\035\064\013\065\021\066\026\001\002\000" +
    "\010\023\ufff8\030\ufff8\035\ufff8\001\002\000\074\004\uff86" +
    "\005\uff86\006\uff86\007\uff86\010\uff86\011\uff86\012\uff86\013" +
    "\uff86\014\uff86\015\uff86\016\uff86\017\uff86\020\uff86\021\uff86" +
    "\022\uff86\023\uff86\024\uff86\027\uff86\030\uff86\032\uff86\033" +
    "\uff86\035\uff86\036\uff86\037\uff86\057\uff86\063\uff86\064\uff86" +
    "\065\uff86\066\uff86\001\002\000\074\004\uff92\005\uff92\006" +
    "\uff92\007\uff92\010\uff92\011\uff92\012\uff92\013\uff92\014\uff92" +
    "\015\uff92\016\uff92\017\uff92\020\uff92\021\uff92\022\uff92\023" +
    "\uff92\024\uff92\027\uff92\030\uff92\032\uff92\033\uff92\035\uff92" +
    "\036\uff92\037\uff92\057\uff92\063\uff92\064\uff92\065\uff92\066" +
    "\uff92\001\002\000\074\004\uff93\005\uff93\006\uff93\007\uff93" +
    "\010\uff93\011\uff93\012\uff93\013\uff93\014\uff93\015\uff93\016" +
    "\uff93\017\uff93\020\uff93\021\uff93\022\uff93\023\uff93\024\uff93" +
    "\027\uff93\030\uff93\032\uff93\033\uff93\035\uff93\036\uff93\037" +
    "\uff93\057\uff93\063\uff93\064\uff93\065\uff93\066\uff93\001\002" +
    "\000\074\004\uff8d\005\uff8d\006\uff8d\007\uff8d\010\uff8d\011" +
    "\uff8d\012\uff8d\013\uff8d\014\uff8d\015\uff8d\016\uff8d\017\uff8d" +
    "\020\uff8d\021\uff8d\022\uff8d\023\uff8d\024\uff8d\027\uff8d\030" +
    "\uff8d\032\uff8d\033\uff8d\035\uff8d\036\uff8d\037\uff8d\057\uff8d" +
    "\063\uff8d\064\uff8d\065\uff8d\066\uff8d\001\002\000\004\023" +
    "\233\001\002\000\046\004\060\005\045\006\055\007\042" +
    "\010\052\011\057\012\053\013\044\014\046\015\061\016" +
    "\047\017\056\020\054\021\050\022\051\023\ufff7\030\ufff7" +
    "\035\ufff7\001\002\000\074\004\uff85\005\uff85\006\uff85\007" +
    "\uff85\010\uff85\011\uff85\012\uff85\013\uff85\014\uff85\015\uff85" +
    "\016\uff85\017\uff85\020\uff85\021\uff85\022\uff85\023\uff85\024" +
    "\uff85\027\uff85\030\uff85\032\uff85\033\uff85\035\uff85\036\uff85" +
    "\037\uff85\057\uff85\063\uff85\064\uff85\065\uff85\066\uff85\001" +
    "\002\000\020\005\022\024\023\036\032\063\035\064\013" +
    "\065\021\066\026\001\002\000\024\040\172\041\166\043" +
    "\167\044\174\045\170\046\171\047\175\055\173\066\165" +
    "\001\002\000\010\023\ufffb\030\163\035\ufffb\001\002\000" +
    "\022\005\022\024\023\032\151\036\032\063\035\064\013" +
    "\065\021\066\026\001\002\000\076\004\uff84\005\uff84\006" +
    "\uff84\007\uff84\010\uff84\011\uff84\012\uff84\013\uff84\014\uff84" +
    "\015\uff84\016\uff84\017\uff84\020\uff84\021\uff84\022\uff84\023" +
    "\uff84\024\uff84\026\101\027\uff84\030\uff84\032\uff84\033\uff84" +
    "\035\uff84\036\uff84\037\uff84\057\uff84\063\uff84\064\uff84\065" +
    "\uff84\066\uff84\001\002\000\074\004\uff91\005\uff91\006\uff91" +
    "\007\uff91\010\uff91\011\uff91\012\uff91\013\uff91\014\uff91\015" +
    "\uff91\016\uff91\017\uff91\020\uff91\021\uff91\022\uff91\023\uff91" +
    "\024\uff91\027\uff91\030\uff91\032\uff91\033\uff91\035\uff91\036" +
    "\uff91\037\uff91\057\uff91\063\uff91\064\uff91\065\uff91\066\uff91" +
    "\001\002\000\074\004\uff8a\005\uff8a\006\uff8a\007\uff8a\010" +
    "\uff8a\011\uff8a\012\uff8a\013\uff8a\014\uff8a\015\uff8a\016\uff8a" +
    "\017\uff8a\020\uff8a\021\uff8a\022\uff8a\023\uff8a\024\uff8a\027" +
    "\uff8a\030\uff8a\032\uff8a\033\uff8a\035\uff8a\036\uff8a\037\uff8a" +
    "\057\uff8a\063\uff8a\064\uff8a\065\uff8a\066\uff8a\001\002\000" +
    "\074\004\uff8c\005\uff8c\006\uff8c\007\uff8c\010\uff8c\011\uff8c" +
    "\012\uff8c\013\uff8c\014\uff8c\015\uff8c\016\uff8c\017\uff8c\020" +
    "\uff8c\021\uff8c\022\uff8c\023\uff8c\024\uff8c\027\uff8c\030\uff8c" +
    "\032\uff8c\033\uff8c\035\uff8c\036\uff8c\037\uff8c\057\uff8c\063" +
    "\uff8c\064\uff8c\065\uff8c\066\uff8c\001\002\000\020\005\022" +
    "\024\023\036\032\063\035\064\013\065\021\066\026\001" +
    "\002\000\074\004\uff8b\005\uff8b\006\uff8b\007\uff8b\010\uff8b" +
    "\011\uff8b\012\uff8b\013\uff8b\014\uff8b\015\uff8b\016\uff8b\017" +
    "\uff8b\020\uff8b\021\uff8b\022\uff8b\023\uff8b\024\uff8b\027\uff8b" +
    "\030\uff8b\032\uff8b\033\uff8b\035\uff8b\036\uff8b\037\uff8b\057" +
    "\uff8b\063\uff8b\064\uff8b\065\uff8b\066\uff8b\001\002\000\074" +
    "\004\uff89\005\uff89\006\uff89\007\uff89\010\uff89\011\uff89\012" +
    "\uff89\013\uff89\014\uff89\015\uff89\016\uff89\017\uff89\020\uff89" +
    "\021\uff89\022\uff89\023\uff89\024\uff89\027\uff89\030\uff89\032" +
    "\uff89\033\uff89\035\uff89\036\uff89\037\uff89\057\uff89\063\uff89" +
    "\064\uff89\065\uff89\066\uff89\001\002\000\074\004\uff87\005" +
    "\uff87\006\uff87\007\uff87\010\uff87\011\uff87\012\uff87\013\uff87" +
    "\014\uff87\015\uff87\016\uff87\017\uff87\020\uff87\021\uff87\022" +
    "\uff87\023\uff87\024\uff87\027\uff87\030\uff87\032\uff87\033\uff87" +
    "\035\uff87\036\uff87\037\uff87\057\uff87\063\uff87\064\uff87\065" +
    "\uff87\066\uff87\001\002\000\074\004\uff88\005\uff88\006\uff88" +
    "\007\uff88\010\uff88\011\uff88\012\uff88\013\uff88\014\uff88\015" +
    "\uff88\016\uff88\017\uff88\020\uff88\021\uff88\022\uff88\023\uff88" +
    "\024\uff88\027\uff88\030\uff88\032\uff88\033\uff88\035\uff88\036" +
    "\uff88\037\uff88\057\uff88\063\uff88\064\uff88\065\uff88\066\uff88" +
    "\001\002\000\074\004\uff8e\005\uff8e\006\uff8e\007\uff8e\010" +
    "\uff8e\011\uff8e\012\uff8e\013\uff8e\014\uff8e\015\uff8e\016\uff8e" +
    "\017\uff8e\020\uff8e\021\uff8e\022\uff8e\023\uff8e\024\uff8e\027" +
    "\uff8e\030\uff8e\032\uff8e\033\uff8e\035\uff8e\036\uff8e\037\uff8e" +
    "\057\uff8e\063\uff8e\064\uff8e\065\uff8e\066\uff8e\001\002\000" +
    "\010\023\ufff6\030\ufff6\035\ufff6\001\002\000\042\004\060" +
    "\005\045\006\055\007\042\010\052\011\057\012\053\013" +
    "\044\014\046\015\061\016\047\017\056\020\054\021\050" +
    "\022\051\037\043\001\002\000\020\005\022\024\023\036" +
    "\032\063\035\064\013\065\021\066\026\001\002\000\074" +
    "\004\uff8f\005\uff8f\006\uff8f\007\uff8f\010\uff8f\011\uff8f\012" +
    "\uff8f\013\uff8f\014\uff8f\015\uff8f\016\uff8f\017\uff8f\020\uff8f" +
    "\021\uff8f\022\uff8f\023\uff8f\024\uff8f\027\uff8f\030\uff8f\032" +
    "\uff8f\033\uff8f\035\uff8f\036\uff8f\037\uff8f\057\uff8f\063\uff8f" +
    "\064\uff8f\065\uff8f\066\uff8f\001\002\000\020\005\022\024" +
    "\023\036\032\063\035\064\013\065\021\066\026\001\002" +
    "\000\020\005\022\024\023\036\032\063\035\064\013\065" +
    "\021\066\026\001\002\000\020\005\022\024\023\036\032" +
    "\063\035\064\013\065\021\066\026\001\002\000\020\005" +
    "\022\024\023\036\032\063\035\064\013\065\021\066\026" +
    "\001\002\000\020\005\022\024\023\036\032\063\035\064" +
    "\013\065\021\066\026\001\002\000\020\005\022\024\023" +
    "\036\032\063\035\064\013\065\021\066\026\001\002\000" +
    "\020\005\022\024\023\036\032\063\035\064\013\065\021" +
    "\066\026\001\002\000\020\005\022\024\023\036\032\063" +
    "\035\064\013\065\021\066\026\001\002\000\020\005\022" +
    "\024\023\036\032\063\035\064\013\065\021\066\026\001" +
    "\002\000\020\005\022\024\023\036\032\063\035\064\013" +
    "\065\021\066\026\001\002\000\020\005\022\024\023\036" +
    "\032\063\035\064\013\065\021\066\026\001\002\000\020" +
    "\005\022\024\023\036\032\063\035\064\013\065\021\066" +
    "\026\001\002\000\020\005\022\024\023\036\032\063\035" +
    "\064\013\065\021\066\026\001\002\000\020\005\022\024" +
    "\023\036\032\063\035\064\013\065\021\066\026\001\002" +
    "\000\074\004\060\005\045\006\055\007\042\010\052\011" +
    "\057\012\053\013\uff98\014\uff98\015\uff98\016\uff98\017\uff98" +
    "\020\uff98\021\uff98\022\uff98\023\uff98\024\uff98\027\uff98\030" +
    "\uff98\032\uff98\033\uff98\035\uff98\036\uff98\037\uff98\057\uff98" +
    "\063\uff98\064\uff98\065\uff98\066\uff98\001\002\000\074\004" +
    "\uffa2\005\uffa2\006\055\007\042\010\052\011\057\012\053" +
    "\013\uffa2\014\uffa2\015\uffa2\016\uffa2\017\uffa2\020\uffa2\021" +
    "\uffa2\022\uffa2\023\uffa2\024\uffa2\027\uffa2\030\uffa2\032\uffa2" +
    "\033\uffa2\035\uffa2\036\uffa2\037\uffa2\057\uffa2\063\uffa2\064" +
    "\uffa2\065\uffa2\066\uffa2\001\002\000\074\004\uff9d\005\uff9d" +
    "\006\uff9d\007\uff9d\010\uff9d\011\057\012\053\013\uff9d\014" +
    "\uff9d\015\uff9d\016\uff9d\017\uff9d\020\uff9d\021\uff9d\022\uff9d" +
    "\023\uff9d\024\uff9d\027\uff9d\030\uff9d\032\uff9d\033\uff9d\035" +
    "\uff9d\036\uff9d\037\uff9d\057\uff9d\063\uff9d\064\uff9d\065\uff9d" +
    "\066\uff9d\001\002\000\074\004\060\005\045\006\055\007" +
    "\042\010\052\011\057\012\053\013\uff96\014\uff96\015\uff96" +
    "\016\uff96\017\uff96\020\uff96\021\uff96\022\uff96\023\uff96\024" +
    "\uff96\027\uff96\030\uff96\032\uff96\033\uff96\035\uff96\036\uff96" +
    "\037\uff96\057\uff96\063\uff96\064\uff96\065\uff96\066\uff96\001" +
    "\002\000\074\004\uffa0\005\uffa0\006\uffa0\007\uffa0\010\uffa0" +
    "\011\057\012\053\013\uffa0\014\uffa0\015\uffa0\016\uffa0\017" +
    "\uffa0\020\uffa0\021\uffa0\022\uffa0\023\uffa0\024\uffa0\027\uffa0" +
    "\030\uffa0\032\uffa0\033\uffa0\035\uffa0\036\uffa0\037\uffa0\057" +
    "\uffa0\063\uffa0\064\uffa0\065\uffa0\066\uffa0\001\002\000\074" +
    "\004\060\005\045\006\055\007\042\010\052\011\057\012" +
    "\053\013\uff97\014\uff97\015\uff97\016\uff97\017\uff97\020\uff97" +
    "\021\uff97\022\uff97\023\uff97\024\uff97\027\uff97\030\uff97\032" +
    "\uff97\033\uff97\035\uff97\036\uff97\037\uff97\057\uff97\063\uff97" +
    "\064\uff97\065\uff97\066\uff97\001\002\000\074\004\uff9c\005" +
    "\uff9c\006\uff9c\007\uff9c\010\uff9c\011\057\012\053\013\uff9c" +
    "\014\uff9c\015\uff9c\016\uff9c\017\uff9c\020\uff9c\021\uff9c\022" +
    "\uff9c\023\uff9c\024\uff9c\027\uff9c\030\uff9c\032\uff9c\033\uff9c" +
    "\035\uff9c\036\uff9c\037\uff9c\057\uff9c\063\uff9c\064\uff9c\065" +
    "\uff9c\066\uff9c\001\002\000\074\004\uff9e\005\uff9e\006\uff9e" +
    "\007\uff9e\010\uff9e\011\057\012\053\013\uff9e\014\uff9e\015" +
    "\uff9e\016\uff9e\017\uff9e\020\uff9e\021\uff9e\022\uff9e\023\uff9e" +
    "\024\uff9e\027\uff9e\030\uff9e\032\uff9e\033\uff9e\035\uff9e\036" +
    "\uff9e\037\uff9e\057\uff9e\063\uff9e\064\uff9e\065\uff9e\066\uff9e" +
    "\001\002\000\074\004\060\005\045\006\055\007\042\010" +
    "\052\011\057\012\053\013\uff94\014\uff94\015\uff94\016\uff94" +
    "\017\uff94\020\uff94\021\uff94\022\uff94\023\uff94\024\uff94\027" +
    "\uff94\030\uff94\032\uff94\033\uff94\035\uff94\036\uff94\037\uff94" +
    "\057\uff94\063\uff94\064\uff94\065\uff94\066\uff94\001\002\000" +
    "\074\004\060\005\045\006\055\007\042\010\052\011\057" +
    "\012\053\013\uff95\014\uff95\015\uff95\016\uff95\017\uff95\020" +
    "\uff95\021\uff95\022\uff95\023\uff95\024\uff95\027\uff95\030\uff95" +
    "\032\uff95\033\uff95\035\uff95\036\uff95\037\uff95\057\uff95\063" +
    "\uff95\064\uff95\065\uff95\066\uff95\001\002\000\074\004\060" +
    "\005\045\006\055\007\042\010\052\011\057\012\053\013" +
    "\uff99\014\uff99\015\uff99\016\uff99\017\uff99\020\uff99\021\uff99" +
    "\022\uff99\023\uff99\024\uff99\027\uff99\030\uff99\032\uff99\033" +
    "\uff99\035\uff99\036\uff99\037\uff99\057\uff99\063\uff99\064\uff99" +
    "\065\uff99\066\uff99\001\002\000\074\004\060\005\045\006" +
    "\055\007\042\010\052\011\057\012\053\013\uff9a\014\uff9a" +
    "\015\061\016\047\017\056\020\054\021\050\022\051\023" +
    "\uff9a\024\uff9a\027\uff9a\030\uff9a\032\uff9a\033\uff9a\035\uff9a" +
    "\036\uff9a\037\uff9a\057\uff9a\063\uff9a\064\uff9a\065\uff9a\066" +
    "\uff9a\001\002\000\074\004\uffa1\005\uffa1\006\055\007\042" +
    "\010\052\011\057\012\053\013\uffa1\014\uffa1\015\uffa1\016" +
    "\uffa1\017\uffa1\020\uffa1\021\uffa1\022\uffa1\023\uffa1\024\uffa1" +
    "\027\uffa1\030\uffa1\032\uffa1\033\uffa1\035\uffa1\036\uffa1\037" +
    "\uffa1\057\uffa1\063\uffa1\064\uffa1\065\uffa1\066\uffa1\001\002" +
    "\000\074\004\060\005\045\006\055\007\042\010\052\011" +
    "\057\012\053\013\uff9b\014\046\015\061\016\047\017\056" +
    "\020\054\021\050\022\051\023\uff9b\024\uff9b\027\uff9b\030" +
    "\uff9b\032\uff9b\033\uff9b\035\uff9b\036\uff9b\037\uff9b\057\uff9b" +
    "\063\uff9b\064\uff9b\065\uff9b\066\uff9b\001\002\000\074\004" +
    "\uff9f\005\uff9f\006\uff9f\007\uff9f\010\uff9f\011\057\012\053" +
    "\013\uff9f\014\uff9f\015\uff9f\016\uff9f\017\uff9f\020\uff9f\021" +
    "\uff9f\022\uff9f\023\uff9f\024\uff9f\027\uff9f\030\uff9f\032\uff9f" +
    "\033\uff9f\035\uff9f\036\uff9f\037\uff9f\057\uff9f\063\uff9f\064" +
    "\uff9f\065\uff9f\066\uff9f\001\002\000\020\005\112\024\023" +
    "\036\111\063\116\064\107\065\114\066\104\001\002\000" +
    "\110\004\uffb1\005\uffb1\006\uffb1\007\uffb1\010\uffb1\011\uffb1" +
    "\012\uffb1\013\uffb1\014\uffb1\015\uffb1\016\uffb1\017\uffb1\020" +
    "\uffb1\021\uffb1\022\uffb1\023\uffb1\024\uffb1\026\uffb1\027\uffb1" +
    "\030\uffb1\031\uffb1\032\uffb1\033\uffb1\035\uffb1\036\uffb1\037" +
    "\uffb1\056\uffb1\057\uffb1\060\uffb1\061\uffb1\062\uffb1\063\uffb1" +
    "\064\uffb1\065\uffb1\066\uffb1\001\002\000\110\004\uffb7\005" +
    "\uffb7\006\uffb7\007\uffb7\010\uffb7\011\uffb7\012\uffb7\013\uffb7" +
    "\014\uffb7\015\uffb7\016\uffb7\017\uffb7\020\uffb7\021\uffb7\022" +
    "\uffb7\023\uffb7\024\uffb7\026\uffb7\027\uffb7\030\uffb7\031\uffb7" +
    "\032\uffb7\033\uffb7\035\uffb7\036\uffb7\037\uffb7\056\uffb7\057" +
    "\uffb7\060\uffb7\061\uffb7\062\uffb7\063\uffb7\064\uffb7\065\uffb7" +
    "\066\uffb7\001\002\000\110\004\uffab\005\uffab\006\uffab\007" +
    "\uffab\010\uffab\011\uffab\012\uffab\013\uffab\014\uffab\015\uffab" +
    "\016\uffab\017\uffab\020\uffab\021\uffab\022\uffab\023\uffab\024" +
    "\uffab\026\uffab\027\uffab\030\uffab\031\uffab\032\uffab\033\uffab" +
    "\035\uffab\036\uffab\037\uffab\056\uffab\057\uffab\060\uffab\061" +
    "\uffab\062\uffab\063\uffab\064\uffab\065\uffab\066\uffab\001\002" +
    "\000\110\004\uffb9\005\uffb9\006\uffb9\007\uffb9\010\uffb9\011" +
    "\uffb9\012\uffb9\013\uffb9\014\uffb9\015\uffb9\016\uffb9\017\uffb9" +
    "\020\uffb9\021\uffb9\022\uffb9\023\uffb9\024\uffb9\026\uffb9\027" +
    "\uffb9\030\uffb9\031\uffb9\032\uffb9\033\uffb9\035\uffb9\036\uffb9" +
    "\037\uffb9\056\uffb9\057\uffb9\060\uffb9\061\uffb9\062\uffb9\063" +
    "\uffb9\064\uffb9\065\uffb9\066\uffb9\001\002\000\110\004\uffaf" +
    "\005\uffaf\006\uffaf\007\uffaf\010\uffaf\011\uffaf\012\uffaf\013" +
    "\uffaf\014\uffaf\015\uffaf\016\uffaf\017\uffaf\020\uffaf\021\uffaf" +
    "\022\uffaf\023\uffaf\024\uffaf\026\uffaf\027\uffaf\030\uffaf\031" +
    "\uffaf\032\uffaf\033\uffaf\035\uffaf\036\uffaf\037\uffaf\056\uffaf" +
    "\057\uffaf\060\uffaf\061\uffaf\062\uffaf\063\uffaf\064\uffaf\065" +
    "\uffaf\066\uffaf\001\002\000\110\004\uffad\005\uffad\006\uffad" +
    "\007\uffad\010\uffad\011\uffad\012\uffad\013\uffad\014\uffad\015" +
    "\uffad\016\uffad\017\uffad\020\uffad\021\uffad\022\uffad\023\uffad" +
    "\024\uffad\026\uffad\027\uffad\030\uffad\031\uffad\032\uffad\033" +
    "\uffad\035\uffad\036\uffad\037\uffad\056\uffad\057\uffad\060\uffad" +
    "\061\uffad\062\uffad\063\uffad\064\uffad\065\uffad\066\uffad\001" +
    "\002\000\110\004\uffb3\005\uffb3\006\uffb3\007\uffb3\010\uffb3" +
    "\011\uffb3\012\uffb3\013\uffb3\014\uffb3\015\uffb3\016\uffb3\017" +
    "\uffb3\020\uffb3\021\uffb3\022\uffb3\023\uffb3\024\uffb3\026\uffb3" +
    "\027\uffb3\030\uffb3\031\uffb3\032\uffb3\033\uffb3\035\uffb3\036" +
    "\uffb3\037\uffb3\056\uffb3\057\uffb3\060\uffb3\061\uffb3\062\uffb3" +
    "\063\uffb3\064\uffb3\065\uffb3\066\uffb3\001\002\000\020\005" +
    "\112\024\023\036\111\063\116\064\107\065\114\066\104" +
    "\001\002\000\020\005\112\024\023\036\111\063\116\064" +
    "\107\065\114\066\104\001\002\000\110\004\uffb8\005\uffb8" +
    "\006\uffb8\007\uffb8\010\uffb8\011\uffb8\012\uffb8\013\uffb8\014" +
    "\uffb8\015\uffb8\016\uffb8\017\uffb8\020\uffb8\021\uffb8\022\uffb8" +
    "\023\uffb8\024\uffb8\026\uffb8\027\uffb8\030\uffb8\031\uffb8\032" +
    "\uffb8\033\uffb8\035\uffb8\036\uffb8\037\uffb8\056\uffb8\057\uffb8" +
    "\060\uffb8\061\uffb8\062\uffb8\063\uffb8\064\uffb8\065\uffb8\066" +
    "\uffb8\001\002\000\110\004\uffac\005\uffac\006\uffac\007\uffac" +
    "\010\uffac\011\uffac\012\uffac\013\uffac\014\uffac\015\uffac\016" +
    "\uffac\017\uffac\020\uffac\021\uffac\022\uffac\023\uffac\024\uffac" +
    "\026\uffac\027\uffac\030\uffac\031\uffac\032\uffac\033\uffac\035" +
    "\uffac\036\uffac\037\uffac\056\uffac\057\uffac\060\uffac\061\uffac" +
    "\062\uffac\063\uffac\064\uffac\065\uffac\066\uffac\001\002\000" +
    "\110\004\uffb2\005\uffb2\006\uffb2\007\uffb2\010\uffb2\011\uffb2" +
    "\012\uffb2\013\uffb2\014\uffb2\015\uffb2\016\uffb2\017\uffb2\020" +
    "\uffb2\021\uffb2\022\uffb2\023\uffb2\024\uffb2\026\uffb2\027\uffb2" +
    "\030\uffb2\031\uffb2\032\uffb2\033\uffb2\035\uffb2\036\uffb2\037" +
    "\uffb2\056\uffb2\057\uffb2\060\uffb2\061\uffb2\062\uffb2\063\uffb2" +
    "\064\uffb2\065\uffb2\066\uffb2\001\002\000\110\004\uffae\005" +
    "\uffae\006\uffae\007\uffae\010\uffae\011\uffae\012\uffae\013\uffae" +
    "\014\uffae\015\uffae\016\uffae\017\uffae\020\uffae\021\uffae\022" +
    "\uffae\023\uffae\024\uffae\026\uffae\027\uffae\030\uffae\031\uffae" +
    "\032\uffae\033\uffae\035\uffae\036\uffae\037\uffae\056\uffae\057" +
    "\uffae\060\uffae\061\uffae\062\uffae\063\uffae\064\uffae\065\uffae" +
    "\066\uffae\001\002\000\110\004\uffb4\005\uffb4\006\uffb4\007" +
    "\uffb4\010\uffb4\011\uffb4\012\uffb4\013\uffb4\014\uffb4\015\uffb4" +
    "\016\uffb4\017\uffb4\020\uffb4\021\uffb4\022\uffb4\023\uffb4\024" +
    "\uffb4\026\uffb4\027\uffb4\030\uffb4\031\uffb4\032\uffb4\033\uffb4" +
    "\035\uffb4\036\uffb4\037\uffb4\056\uffb4\057\uffb4\060\uffb4\061" +
    "\uffb4\062\uffb4\063\uffb4\064\uffb4\065\uffb4\066\uffb4\001\002" +
    "\000\110\004\132\005\124\006\130\007\122\010\126\011" +
    "\131\012\127\013\uffc1\014\uffc1\015\uffc1\016\uffc1\017\uffc1" +
    "\020\uffc1\021\uffc1\022\uffc1\023\uffc1\024\uffc1\026\125\027" +
    "\uffc1\030\uffc1\031\uffc1\032\uffc1\033\uffc1\035\uffc1\036\uffc1" +
    "\037\uffc1\056\uffc1\057\uffc1\060\uffc1\061\uffc1\062\uffc1\063" +
    "\uffc1\064\uffc1\065\uffc1\066\uffc1\001\002\000\110\004\uffb0" +
    "\005\uffb0\006\uffb0\007\uffb0\010\uffb0\011\uffb0\012\uffb0\013" +
    "\uffb0\014\uffb0\015\uffb0\016\uffb0\017\uffb0\020\uffb0\021\uffb0" +
    "\022\uffb0\023\uffb0\024\uffb0\026\uffb0\027\uffb0\030\uffb0\031" +
    "\uffb0\032\uffb0\033\uffb0\035\uffb0\036\uffb0\037\uffb0\056\uffb0" +
    "\057\uffb0\060\uffb0\061\uffb0\062\uffb0\063\uffb0\064\uffb0\065" +
    "\uffb0\066\uffb0\001\002\000\020\005\112\024\023\036\111" +
    "\063\116\064\107\065\114\066\104\001\002\000\106\004" +
    "\uffc3\005\uffc3\006\uffc3\007\uffc3\010\uffc3\011\uffc3\012\uffc3" +
    "\013\uffc3\014\uffc3\015\uffc3\016\uffc3\017\uffc3\020\uffc3\021" +
    "\uffc3\022\uffc3\023\uffc3\024\uffc3\027\uffc3\030\uffc3\031\uffc3" +
    "\032\uffc3\033\uffc3\035\uffc3\036\uffc3\037\uffc3\056\uffc3\057" +
    "\uffc3\060\uffc3\061\uffc3\062\uffc3\063\uffc3\064\uffc3\065\uffc3" +
    "\066\uffc3\001\002\000\020\005\112\024\023\036\111\063" +
    "\116\064\107\065\114\066\104\001\002\000\020\005\112" +
    "\024\023\036\111\063\116\064\107\065\114\066\104\001" +
    "\002\000\020\005\112\024\023\036\111\063\116\064\107" +
    "\065\114\066\104\001\002\000\020\005\112\024\023\036" +
    "\111\063\116\064\107\065\114\066\104\001\002\000\020" +
    "\005\112\024\023\036\111\063\116\064\107\065\114\066" +
    "\104\001\002\000\020\005\112\024\023\036\111\063\116" +
    "\064\107\065\114\066\104\001\002\000\020\005\112\024" +
    "\023\036\111\063\116\064\107\065\114\066\104\001\002" +
    "\000\110\004\uffc0\005\uffc0\006\130\007\122\010\126\011" +
    "\131\012\127\013\uffc0\014\uffc0\015\uffc0\016\uffc0\017\uffc0" +
    "\020\uffc0\021\uffc0\022\uffc0\023\uffc0\024\uffc0\026\uffc0\027" +
    "\uffc0\030\uffc0\031\uffc0\032\uffc0\033\uffc0\035\uffc0\036\uffc0" +
    "\037\uffc0\056\uffc0\057\uffc0\060\uffc0\061\uffc0\062\uffc0\063" +
    "\uffc0\064\uffc0\065\uffc0\066\uffc0\001\002\000\110\004\uffbb" +
    "\005\uffbb\006\uffbb\007\uffbb\010\uffbb\011\131\012\127\013" +
    "\uffbb\014\uffbb\015\uffbb\016\uffbb\017\uffbb\020\uffbb\021\uffbb" +
    "\022\uffbb\023\uffbb\024\uffbb\026\uffbb\027\uffbb\030\uffbb\031" +
    "\uffbb\032\uffbb\033\uffbb\035\uffbb\036\uffbb\037\uffbb\056\uffbb" +
    "\057\uffbb\060\uffbb\061\uffbb\062\uffbb\063\uffbb\064\uffbb\065" +
    "\uffbb\066\uffbb\001\002\000\110\004\uffbe\005\uffbe\006\uffbe" +
    "\007\uffbe\010\uffbe\011\131\012\127\013\uffbe\014\uffbe\015" +
    "\uffbe\016\uffbe\017\uffbe\020\uffbe\021\uffbe\022\uffbe\023\uffbe" +
    "\024\uffbe\026\uffbe\027\uffbe\030\uffbe\031\uffbe\032\uffbe\033" +
    "\uffbe\035\uffbe\036\uffbe\037\uffbe\056\uffbe\057\uffbe\060\uffbe" +
    "\061\uffbe\062\uffbe\063\uffbe\064\uffbe\065\uffbe\066\uffbe\001" +
    "\002\000\110\004\uffba\005\uffba\006\uffba\007\uffba\010\uffba" +
    "\011\131\012\127\013\uffba\014\uffba\015\uffba\016\uffba\017" +
    "\uffba\020\uffba\021\uffba\022\uffba\023\uffba\024\uffba\026\uffba" +
    "\027\uffba\030\uffba\031\uffba\032\uffba\033\uffba\035\uffba\036" +
    "\uffba\037\uffba\056\uffba\057\uffba\060\uffba\061\uffba\062\uffba" +
    "\063\uffba\064\uffba\065\uffba\066\uffba\001\002\000\110\004" +
    "\uffbc\005\uffbc\006\uffbc\007\uffbc\010\uffbc\011\131\012\127" +
    "\013\uffbc\014\uffbc\015\uffbc\016\uffbc\017\uffbc\020\uffbc\021" +
    "\uffbc\022\uffbc\023\uffbc\024\uffbc\026\uffbc\027\uffbc\030\uffbc" +
    "\031\uffbc\032\uffbc\033\uffbc\035\uffbc\036\uffbc\037\uffbc\056" +
    "\uffbc\057\uffbc\060\uffbc\061\uffbc\062\uffbc\063\uffbc\064\uffbc" +
    "\065\uffbc\066\uffbc\001\002\000\106\004\132\005\124\006" +
    "\130\007\122\010\126\011\131\012\127\013\uffc2\014\uffc2" +
    "\015\uffc2\016\uffc2\017\uffc2\020\uffc2\021\uffc2\022\uffc2\023" +
    "\uffc2\024\uffc2\027\uffc2\030\uffc2\031\uffc2\032\uffc2\033\uffc2" +
    "\035\uffc2\036\uffc2\037\uffc2\056\uffc2\057\uffc2\060\uffc2\061" +
    "\uffc2\062\uffc2\063\uffc2\064\uffc2\065\uffc2\066\uffc2\001\002" +
    "\000\110\004\uffbf\005\uffbf\006\130\007\122\010\126\011" +
    "\131\012\127\013\uffbf\014\uffbf\015\uffbf\016\uffbf\017\uffbf" +
    "\020\uffbf\021\uffbf\022\uffbf\023\uffbf\024\uffbf\026\uffbf\027" +
    "\uffbf\030\uffbf\031\uffbf\032\uffbf\033\uffbf\035\uffbf\036\uffbf" +
    "\037\uffbf\056\uffbf\057\uffbf\060\uffbf\061\uffbf\062\uffbf\063" +
    "\uffbf\064\uffbf\065\uffbf\066\uffbf\001\002\000\110\004\uffbd" +
    "\005\uffbd\006\uffbd\007\uffbd\010\uffbd\011\131\012\127\013" +
    "\uffbd\014\uffbd\015\uffbd\016\uffbd\017\uffbd\020\uffbd\021\uffbd" +
    "\022\uffbd\023\uffbd\024\uffbd\026\uffbd\027\uffbd\030\uffbd\031" +
    "\uffbd\032\uffbd\033\uffbd\035\uffbd\036\uffbd\037\uffbd\056\uffbd" +
    "\057\uffbd\060\uffbd\061\uffbd\062\uffbd\063\uffbd\064\uffbd\065" +
    "\uffbd\066\uffbd\001\002\000\110\004\uffb6\005\uffb6\006\130" +
    "\007\122\010\126\011\131\012\127\013\uffb6\014\uffb6\015" +
    "\uffb6\016\uffb6\017\uffb6\020\uffb6\021\uffb6\022\uffb6\023\uffb6" +
    "\024\uffb6\026\uffb6\027\uffb6\030\uffb6\031\uffb6\032\uffb6\033" +
    "\uffb6\035\uffb6\036\uffb6\037\uffb6\056\uffb6\057\uffb6\060\uffb6" +
    "\061\uffb6\062\uffb6\063\uffb6\064\uffb6\065\uffb6\066\uffb6\001" +
    "\002\000\022\004\132\005\124\006\130\007\122\010\126" +
    "\011\131\012\127\037\145\001\002\000\110\004\uffb5\005" +
    "\uffb5\006\uffb5\007\uffb5\010\uffb5\011\uffb5\012\uffb5\013\uffb5" +
    "\014\uffb5\015\uffb5\016\uffb5\017\uffb5\020\uffb5\021\uffb5\022" +
    "\uffb5\023\uffb5\024\uffb5\026\uffb5\027\uffb5\030\uffb5\031\uffb5" +
    "\032\uffb5\033\uffb5\035\uffb5\036\uffb5\037\uffb5\056\uffb5\057" +
    "\uffb5\060\uffb5\061\uffb5\062\uffb5\063\uffb5\064\uffb5\065\uffb5" +
    "\066\uffb5\001\002\000\004\033\162\001\002\000\044\004" +
    "\060\005\045\006\055\007\042\010\052\011\057\012\053" +
    "\013\044\014\046\015\061\016\047\017\056\020\054\021" +
    "\050\022\051\030\uffa6\033\uffa6\001\002\000\006\030\160" +
    "\033\uffa8\001\002\000\020\005\022\024\023\036\032\063" +
    "\035\064\013\065\021\066\026\001\002\000\006\030\154" +
    "\033\uffa9\001\002\000\006\030\uffa4\033\uffa4\001\002\000" +
    "\020\005\022\024\023\036\032\063\035\064\013\065\021" +
    "\066\026\001\002\000\044\004\060\005\045\006\055\007" +
    "\042\010\052\011\057\012\053\013\044\014\046\015\061" +
    "\016\047\017\056\020\054\021\050\022\051\030\uffa7\033" +
    "\uffa7\001\002\000\006\030\154\033\157\001\002\000\006" +
    "\030\uffa3\033\uffa3\001\002\000\004\032\151\001\002\000" +
    "\006\030\uffa5\033\uffa5\001\002\000\046\005\uffaa\023\uffaa" +
    "\024\uffaa\025\uffaa\027\uffaa\030\uffaa\031\uffaa\032\uffaa\035" +
    "\uffaa\036\uffaa\056\uffaa\060\uffaa\061\uffaa\062\uffaa\063\uffaa" +
    "\064\uffaa\065\uffaa\066\uffaa\001\002\000\022\005\022\024" +
    "\023\032\025\036\032\063\035\064\013\065\021\066\026" +
    "\001\002\000\010\023\ufff9\030\ufff9\035\ufff9\001\002\000" +
    "\004\034\226\001\002\000\020\005\022\024\023\036\032" +
    "\063\035\064\013\065\021\066\026\001\002\000\006\032" +
    "\025\066\207\001\002\000\020\005\022\024\023\036\032" +
    "\063\035\064\013\065\021\066\026\001\002\000\010\032" +
    "\025\064\176\066\202\001\002\000\020\005\022\024\023" +
    "\036\032\063\035\064\013\065\021\066\026\001\002\000" +
    "\010\032\025\064\176\066\202\001\002\000\006\032\025" +
    "\066\207\001\002\000\010\032\025\064\176\066\202\001" +
    "\002\000\026\024\uffc4\025\uffc4\031\uffc4\032\uffc4\056\uffc4" +
    "\060\uffc4\061\uffc4\062\uffc4\064\uffc4\066\uffc4\001\002\000" +
    "\026\024\uffc6\025\uffc6\031\uffc6\032\uffc6\056\uffc6\060\uffc6" +
    "\061\uffc6\062\uffc6\064\uffc6\066\uffc6\001\002\000\006\024" +
    "\204\025\203\001\002\000\026\024\uffc7\025\uffc7\031\uffc7" +
    "\032\uffc7\056\uffc7\060\uffc7\061\uffc7\062\uffc7\064\uffc7\066" +
    "\uffc7\001\002\000\026\024\uffc5\025\uffc5\031\uffc5\032\uffc5" +
    "\056\uffc5\060\uffc5\061\uffc5\062\uffc5\064\uffc5\066\uffc5\001" +
    "\002\000\010\032\025\064\176\066\202\001\002\000\110" +
    "\004\uffcf\005\uffcf\006\uffcf\007\uffcf\010\uffcf\011\uffcf\012" +
    "\uffcf\013\uffcf\014\uffcf\015\uffcf\016\uffcf\017\uffcf\020\uffcf" +
    "\021\uffcf\022\uffcf\023\uffcf\024\uffcf\026\uffcf\027\uffcf\030" +
    "\uffcf\031\uffcf\032\uffcf\033\uffcf\035\uffcf\036\uffcf\037\uffcf" +
    "\056\uffcf\057\uffcf\060\uffcf\061\uffcf\062\uffcf\063\uffcf\064" +
    "\uffcf\065\uffcf\066\uffcf\001\002\000\026\024\uffc8\025\uffc8" +
    "\031\uffc8\032\uffc8\056\uffc8\060\uffc8\061\uffc8\062\uffc8\064" +
    "\uffc8\066\uffc8\001\002\000\004\024\uffd1\001\002\000\004" +
    "\024\uffd2\001\002\000\004\024\211\001\002\000\110\004" +
    "\uffd3\005\uffd3\006\uffd3\007\uffd3\010\uffd3\011\uffd3\012\uffd3" +
    "\013\uffd3\014\uffd3\015\uffd3\016\uffd3\017\uffd3\020\uffd3\021" +
    "\uffd3\022\uffd3\023\uffd3\024\uffd3\026\uffd3\027\uffd3\030\uffd3" +
    "\031\uffd3\032\uffd3\033\uffd3\035\uffd3\036\uffd3\037\uffd3\056" +
    "\uffd3\057\uffd3\060\uffd3\061\uffd3\062\uffd3\063\uffd3\064\uffd3" +
    "\065\uffd3\066\uffd3\001\002\000\006\024\213\025\203\001" +
    "\002\000\110\004\uffc9\005\uffc9\006\uffc9\007\uffc9\010\uffc9" +
    "\011\uffc9\012\uffc9\013\uffc9\014\uffc9\015\uffc9\016\uffc9\017" +
    "\uffc9\020\uffc9\021\uffc9\022\uffc9\023\uffc9\024\uffc9\026\uffc9" +
    "\027\uffc9\030\uffc9\031\uffc9\032\uffc9\033\uffc9\035\uffc9\036" +
    "\uffc9\037\uffc9\056\uffc9\057\uffc9\060\uffc9\061\uffc9\062\uffc9" +
    "\063\uffc9\064\uffc9\065\uffc9\066\uffc9\001\002\000\042\004" +
    "\060\005\045\006\055\007\042\010\052\011\057\012\053" +
    "\013\044\014\046\015\061\016\047\017\056\020\054\021" +
    "\050\022\051\024\215\001\002\000\110\004\uffd6\005\uffd6" +
    "\006\uffd6\007\uffd6\010\uffd6\011\uffd6\012\uffd6\013\uffd6\014" +
    "\uffd6\015\uffd6\016\uffd6\017\uffd6\020\uffd6\021\uffd6\022\uffd6" +
    "\023\uffd6\024\uffd6\026\uffd6\027\uffd6\030\uffd6\031\uffd6\032" +
    "\uffd6\033\uffd6\035\uffd6\036\uffd6\037\uffd6\056\uffd6\057\uffd6" +
    "\060\uffd6\061\uffd6\062\uffd6\063\uffd6\064\uffd6\065\uffd6\066" +
    "\uffd6\001\002\000\006\024\217\025\203\001\002\000\110" +
    "\004\uffd0\005\uffd0\006\uffd0\007\uffd0\010\uffd0\011\uffd0\012" +
    "\uffd0\013\uffd0\014\uffd0\015\uffd0\016\uffd0\017\uffd0\020\uffd0" +
    "\021\uffd0\022\uffd0\023\uffd0\024\uffd0\026\uffd0\027\uffd0\030" +
    "\uffd0\031\uffd0\032\uffd0\033\uffd0\035\uffd0\036\uffd0\037\uffd0" +
    "\056\uffd0\057\uffd0\060\uffd0\061\uffd0\062\uffd0\063\uffd0\064" +
    "\uffd0\065\uffd0\066\uffd0\001\002\000\042\004\060\005\045" +
    "\006\055\007\042\010\052\011\057\012\053\013\044\014" +
    "\046\015\061\016\047\017\056\020\054\021\050\022\051" +
    "\024\221\001\002\000\110\004\uffd7\005\uffd7\006\uffd7\007" +
    "\uffd7\010\uffd7\011\uffd7\012\uffd7\013\uffd7\014\uffd7\015\uffd7" +
    "\016\uffd7\017\uffd7\020\uffd7\021\uffd7\022\uffd7\023\uffd7\024" +
    "\uffd7\026\uffd7\027\uffd7\030\uffd7\031\uffd7\032\uffd7\033\uffd7" +
    "\035\uffd7\036\uffd7\037\uffd7\056\uffd7\057\uffd7\060\uffd7\061" +
    "\uffd7\062\uffd7\063\uffd7\064\uffd7\065\uffd7\066\uffd7\001\002" +
    "\000\004\024\223\001\002\000\110\004\uffd4\005\uffd4\006" +
    "\uffd4\007\uffd4\010\uffd4\011\uffd4\012\uffd4\013\uffd4\014\uffd4" +
    "\015\uffd4\016\uffd4\017\uffd4\020\uffd4\021\uffd4\022\uffd4\023" +
    "\uffd4\024\uffd4\026\uffd4\027\uffd4\030\uffd4\031\uffd4\032\uffd4" +
    "\033\uffd4\035\uffd4\036\uffd4\037\uffd4\056\uffd4\057\uffd4\060" +
    "\uffd4\061\uffd4\062\uffd4\063\uffd4\064\uffd4\065\uffd4\066\uffd4" +
    "\001\002\000\042\004\060\005\045\006\055\007\042\010" +
    "\052\011\057\012\053\013\044\014\046\015\061\016\047" +
    "\017\056\020\054\021\050\022\051\024\225\001\002\000" +
    "\110\004\uffd5\005\uffd5\006\uffd5\007\uffd5\010\uffd5\011\uffd5" +
    "\012\uffd5\013\uffd5\014\uffd5\015\uffd5\016\uffd5\017\uffd5\020" +
    "\uffd5\021\uffd5\022\uffd5\023\uffd5\024\uffd5\026\uffd5\027\uffd5" +
    "\030\uffd5\031\uffd5\032\uffd5\033\uffd5\035\uffd5\036\uffd5\037" +
    "\uffd5\056\uffd5\057\uffd5\060\uffd5\061\uffd5\062\uffd5\063\uffd5" +
    "\064\uffd5\065\uffd5\066\uffd5\001\002\000\024\005\022\024" +
    "\023\032\025\035\ufffa\036\032\063\035\064\013\065\021" +
    "\066\026\001\002\000\004\035\230\001\002\000\004\024" +
    "\231\001\002\000\110\004\uff83\005\uff83\006\uff83\007\uff83" +
    "\010\uff83\011\uff83\012\uff83\013\uff83\014\uff83\015\uff83\016" +
    "\uff83\017\uff83\020\uff83\021\uff83\022\uff83\023\uff83\024\uff83" +
    "\026\uff83\027\uff83\030\uff83\031\uff83\032\uff83\033\uff83\035" +
    "\uff83\036\uff83\037\uff83\056\uff83\057\uff83\060\uff83\061\uff83" +
    "\062\uff83\063\uff83\064\uff83\065\uff83\066\uff83\001\002\000" +
    "\074\004\uff90\005\uff90\006\055\007\042\010\052\011\057" +
    "\012\053\013\uff90\014\uff90\015\uff90\016\uff90\017\uff90\020" +
    "\uff90\021\uff90\022\uff90\023\uff90\024\uff90\027\uff90\030\uff90" +
    "\032\uff90\033\uff90\035\uff90\036\uff90\037\uff90\057\uff90\063" +
    "\uff90\064\uff90\065\uff90\066\uff90\001\002\000\016\024\247" +
    "\032\025\056\264\061\237\064\176\066\251\001\002\000" +
    "\024\024\uffdd\031\uffdd\032\uffdd\056\uffdd\060\uffdd\061\uffdd" +
    "\062\uffdd\064\uffdd\066\uffdd\001\002\000\026\024\uffdb\025" +
    "\203\031\uffdb\032\uffdb\056\uffdb\060\uffdb\061\uffdb\062\uffdb" +
    "\064\uffdb\066\uffdb\001\002\000\024\024\uffe2\031\uffe2\032" +
    "\uffe2\056\uffe2\060\uffe2\061\uffe2\062\uffe2\064\uffe2\066\uffe2" +
    "\001\002\000\022\005\022\024\023\032\025\036\032\063" +
    "\035\064\013\065\021\066\026\001\002\000\020\024\247" +
    "\032\025\056\264\061\237\062\321\064\176\066\251\001" +
    "\002\000\024\024\uffe3\031\uffe3\032\uffe3\056\uffe3\060\uffe3" +
    "\061\uffe3\062\uffe3\064\uffe3\066\uffe3\001\002\000\024\024" +
    "\uffd9\031\uffd9\032\uffd9\056\uffd9\060\uffd9\061\uffd9\062\uffd9" +
    "\064\uffd9\066\uffd9\001\002\000\024\024\ufff3\031\ufff3\032" +
    "\ufff3\056\ufff3\060\ufff3\061\ufff3\062\ufff3\064\ufff3\066\ufff3" +
    "\001\002\000\024\024\uffe9\031\uffe9\032\uffe9\056\uffe9\060" +
    "\uffe9\061\uffe9\062\uffe9\064\uffe9\066\uffe9\001\002\000\024" +
    "\024\ufff4\031\ufff4\032\ufff4\056\ufff4\060\ufff4\061\ufff4\062" +
    "\ufff4\064\ufff4\066\ufff4\001\002\000\024\024\ufff1\031\ufff1" +
    "\032\ufff1\056\ufff1\060\ufff1\061\ufff1\062\ufff1\064\ufff1\066" +
    "\ufff1\001\002\000\040\040\172\041\166\042\275\043\167" +
    "\044\174\045\170\046\171\047\175\050\301\051\276\052" +
    "\300\053\302\054\277\055\173\066\165\001\002\000\024" +
    "\024\uffe1\031\uffe1\032\uffe1\056\uffe1\060\uffe1\061\uffe1\062" +
    "\uffe1\064\uffe1\066\uffe1\001\002\000\030\024\uffc5\025\uffc5" +
    "\026\101\031\uffc5\032\uffc5\056\uffc5\060\uffc5\061\uffc5\062" +
    "\uffc5\064\uffc5\066\uffc5\001\002\000\024\024\uffdf\031\uffdf" +
    "\032\uffdf\056\uffdf\060\uffdf\061\uffdf\062\uffdf\064\uffdf\066" +
    "\uffdf\001\002\000\024\024\uffe6\031\uffe6\032\uffe6\056\uffe6" +
    "\060\uffe6\061\uffe6\062\uffe6\064\uffe6\066\uffe6\001\002\000" +
    "\024\024\uffdc\031\uffdc\032\uffdc\056\uffdc\060\uffdc\061\uffdc" +
    "\062\uffdc\064\uffdc\066\uffdc\001\002\000\024\024\ufff2\031" +
    "\ufff2\032\ufff2\056\ufff2\060\ufff2\061\ufff2\062\ufff2\064\ufff2" +
    "\066\ufff2\001\002\000\024\024\uffda\031\uffda\032\uffda\056" +
    "\uffda\060\uffda\061\uffda\062\uffda\064\uffda\066\uffda\001\002" +
    "\000\024\024\uffe7\031\uffe7\032\uffe7\056\uffe7\060\uffe7\061" +
    "\uffe7\062\uffe7\064\uffe7\066\uffe7\001\002\000\024\024\uffde" +
    "\031\uffde\032\uffde\056\uffde\060\uffde\061\uffde\062\uffde\064" +
    "\uffde\066\uffde\001\002\000\024\024\uffe5\031\uffe5\032\uffe5" +
    "\056\uffe5\060\uffe5\061\uffe5\062\uffe5\064\uffe5\066\uffe5\001" +
    "\002\000\024\024\uffe8\031\uffe8\032\uffe8\056\uffe8\060\uffe8" +
    "\061\uffe8\062\uffe8\064\uffe8\066\uffe8\001\002\000\024\024" +
    "\uffe4\031\uffe4\032\uffe4\056\uffe4\060\uffe4\061\uffe4\062\uffe4" +
    "\064\uffe4\066\uffe4\001\002\000\020\005\022\024\023\036" +
    "\032\063\035\064\013\065\021\066\026\001\002\000\024" +
    "\024\uffe0\031\uffe0\032\uffe0\056\uffe0\060\uffe0\061\uffe0\062" +
    "\uffe0\064\uffe0\066\uffe0\001\002\000\042\004\060\005\045" +
    "\006\055\007\042\010\052\011\057\012\053\013\044\014" +
    "\046\015\061\016\047\017\056\020\054\021\050\022\051" +
    "\057\267\001\002\000\016\024\247\032\025\056\264\061" +
    "\237\064\176\066\251\001\002\000\020\024\247\032\025" +
    "\056\264\060\271\061\237\064\176\066\251\001\002\000" +
    "\016\024\247\032\025\056\264\061\237\064\176\066\251" +
    "\001\002\000\024\024\ufff5\031\ufff5\032\ufff5\056\ufff5\060" +
    "\ufff5\061\ufff5\062\ufff5\064\ufff5\066\ufff5\001\002\000\020" +
    "\024\247\032\025\056\264\061\237\062\274\064\176\066" +
    "\251\001\002\000\024\024\ufff0\031\ufff0\032\ufff0\056\ufff0" +
    "\060\ufff0\061\ufff0\062\ufff0\064\ufff0\066\ufff0\001\002\000" +
    "\004\066\315\001\002\000\010\032\025\064\176\066\202" +
    "\001\002\000\010\032\025\064\176\066\202\001\002\000" +
    "\010\032\025\064\176\066\202\001\002\000\010\032\025" +
    "\064\176\066\202\001\002\000\010\032\025\064\176\066" +
    "\202\001\002\000\006\024\304\025\203\001\002\000\024" +
    "\024\uffcb\031\uffcb\032\uffcb\056\uffcb\060\uffcb\061\uffcb\062" +
    "\uffcb\064\uffcb\066\uffcb\001\002\000\006\024\306\025\203" +
    "\001\002\000\024\024\uffce\031\uffce\032\uffce\056\uffce\060" +
    "\uffce\061\uffce\062\uffce\064\uffce\066\uffce\001\002\000\006" +
    "\024\310\025\203\001\002\000\024\024\uffcc\031\uffcc\032" +
    "\uffcc\056\uffcc\060\uffcc\061\uffcc\062\uffcc\064\uffcc\066\uffcc" +
    "\001\002\000\006\024\312\025\203\001\002\000\024\024" +
    "\uffca\031\uffca\032\uffca\056\uffca\060\uffca\061\uffca\062\uffca" +
    "\064\uffca\066\uffca\001\002\000\006\024\314\025\203\001" +
    "\002\000\024\024\uffcd\031\uffcd\032\uffcd\056\uffcd\060\uffcd" +
    "\061\uffcd\062\uffcd\064\uffcd\066\uffcd\001\002\000\004\023" +
    "\316\001\002\000\010\032\025\064\176\066\202\001\002" +
    "\000\006\024\320\025\203\001\002\000\024\024\uffd8\031" +
    "\uffd8\032\uffd8\056\uffd8\060\uffd8\061\uffd8\062\uffd8\064\uffd8" +
    "\066\uffd8\001\002\000\006\002\ufffc\066\ufffc\001\002\000" +
    "\022\005\022\024\023\032\025\036\032\063\035\064\013" +
    "\065\021\066\026\001\002\000\060\004\060\005\045\006" +
    "\055\007\042\010\052\011\057\012\053\013\044\014\046" +
    "\015\061\016\047\017\056\020\054\021\050\022\051\024" +
    "\uffeb\027\uffeb\032\uffeb\036\uffeb\063\uffeb\064\uffeb\065\uffeb" +
    "\066\uffeb\001\002\000\024\005\uffea\024\uffea\027\uffea\032" +
    "\uffea\036\uffea\063\uffea\064\uffea\065\uffea\066\uffea\001\002" +
    "\000\024\005\022\024\023\032\025\036\032\062\334\063" +
    "\035\064\013\065\021\066\026\001\002\000\004\027\330" +
    "\001\002\000\024\005\uffed\024\uffed\032\uffed\036\uffed\062" +
    "\uffed\063\uffed\064\uffed\065\uffed\066\uffed\001\002\000\016" +
    "\024\247\032\025\056\264\061\237\064\176\066\251\001" +
    "\002\000\020\024\247\031\332\032\025\056\264\061\237" +
    "\064\176\066\251\001\002\000\024\005\uffec\024\uffec\032" +
    "\uffec\036\uffec\062\uffec\063\uffec\064\uffec\065\uffec\066\uffec" +
    "\001\002\000\024\005\uffee\024\uffee\032\uffee\036\uffee\062" +
    "\uffee\063\uffee\064\uffee\065\uffee\066\uffee\001\002\000\024" +
    "\024\uffef\031\uffef\032\uffef\056\uffef\060\uffef\061\uffef\062" +
    "\uffef\064\uffef\066\uffef\001\002\000\006\002\ufffe\066\ufffe" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\333\000\006\002\004\053\003\001\001\000\006\005" +
    "\007\006\006\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\006\334\001\001\000\040\003" +
    "\011\004\023\010\015\014\016\016\037\023\017\024\036" +
    "\033\032\034\027\035\033\036\035\041\014\042\013\050" +
    "\026\052\030\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\030" +
    "\010\015\023\231\024\036\033\032\034\027\035\033\036" +
    "\035\041\014\042\013\050\026\052\030\001\001\000\002" +
    "\001\001\000\002\001\001\000\040\010\015\013\152\017" +
    "\145\020\147\021\151\023\146\024\036\033\032\034\027" +
    "\035\033\036\035\041\014\042\013\050\026\052\030\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\030\010\015\023\040\024\036\033" +
    "\032\034\027\035\033\036\035\041\014\042\013\050\026" +
    "\052\030\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\030\010\015\023\077\024" +
    "\036\033\032\034\027\035\033\036\035\041\014\042\013" +
    "\050\026\052\030\001\001\000\002\001\001\000\030\010" +
    "\015\023\076\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\075\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\074\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\073\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\072\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\071\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\070\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\067\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\066\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\065\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\064\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\063\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\062\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\030\010" +
    "\015\023\061\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\026\010\107\024\116\025\117" +
    "\033\114\034\101\035\120\036\105\041\104\042\112\050" +
    "\102\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\026\010\107\024\116\025\143" +
    "\033\114\034\101\035\120\036\105\041\104\042\112\050" +
    "\102\001\001\000\026\010\107\024\116\025\142\033\114" +
    "\034\101\035\120\036\105\041\104\042\112\050\102\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\026\122\001" +
    "\001\000\002\001\001\000\026\010\107\024\116\025\141" +
    "\033\114\034\101\035\120\036\105\041\104\042\112\050" +
    "\102\001\001\000\002\001\001\000\026\010\107\024\116" +
    "\025\140\033\114\034\101\035\120\036\105\041\104\042" +
    "\112\050\102\001\001\000\026\010\107\024\116\025\137" +
    "\033\114\034\101\035\120\036\105\041\104\042\112\050" +
    "\102\001\001\000\026\010\107\024\116\025\136\033\114" +
    "\034\101\035\120\036\105\041\104\042\112\050\102\001" +
    "\001\000\026\010\107\024\116\025\135\033\114\034\101" +
    "\035\120\036\105\041\104\042\112\050\102\001\001\000" +
    "\026\010\107\024\116\025\134\033\114\034\101\035\120" +
    "\036\105\041\104\042\112\050\102\001\001\000\026\010" +
    "\107\024\116\025\133\033\114\034\101\035\120\036\105" +
    "\041\104\042\112\050\102\001\001\000\026\010\107\024" +
    "\116\025\132\033\114\034\101\035\120\036\105\041\104" +
    "\042\112\050\102\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\032\010" +
    "\015\021\155\023\146\024\036\033\032\034\027\035\033" +
    "\036\035\041\014\042\013\050\026\052\030\001\001\000" +
    "\002\001\001\000\002\001\001\000\030\010\015\023\154" +
    "\024\036\033\032\034\027\035\033\036\035\041\014\042" +
    "\013\050\026\052\030\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\013\160\001\001\000" +
    "\002\001\001\000\002\001\001\000\034\003\163\010\015" +
    "\016\037\023\017\024\036\033\032\034\027\035\033\036" +
    "\035\041\014\042\013\050\026\052\030\001\001\000\002" +
    "\001\001\000\002\001\001\000\030\010\015\023\223\024" +
    "\036\033\032\034\027\035\033\036\035\041\014\042\013" +
    "\050\026\052\030\001\001\000\006\016\205\037\221\001" +
    "\001\000\030\010\015\023\217\024\036\033\032\034\027" +
    "\035\033\036\035\041\014\042\013\050\026\052\030\001" +
    "\001\000\010\016\176\040\200\051\215\001\001\000\030" +
    "\010\015\023\213\024\036\033\032\034\027\035\033\036" +
    "\035\041\014\042\013\050\026\052\030\001\001\000\010" +
    "\016\176\040\200\051\211\001\001\000\006\016\205\037" +
    "\207\001\001\000\010\016\176\040\200\051\177\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\016\176\040\204" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\040\003\011" +
    "\004\023\010\015\014\226\016\037\023\017\024\036\033" +
    "\032\034\027\035\033\036\035\041\014\042\013\050\026" +
    "\052\030\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\062\007\245\010\241" +
    "\011\237\012\244\015\243\016\176\024\261\027\242\030" +
    "\254\033\256\034\252\035\260\036\262\040\200\041\240" +
    "\042\235\043\247\044\264\045\251\046\257\047\233\050" +
    "\253\051\234\052\255\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\034\010\015\016\323\022" +
    "\321\023\322\024\036\033\032\034\027\035\033\036\035" +
    "\041\014\042\013\050\026\052\030\001\001\000\060\007" +
    "\245\010\241\012\271\015\243\016\176\024\261\027\242" +
    "\030\254\033\256\034\252\035\260\036\262\040\200\041" +
    "\240\042\235\043\247\044\264\045\251\046\257\047\233" +
    "\050\253\051\234\052\255\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\030\010\015\023\265\024" +
    "\036\033\032\034\027\035\033\036\035\041\014\042\013" +
    "\050\026\052\030\001\001\000\002\001\001\000\002\001" +
    "\001\000\062\007\245\010\241\011\267\012\244\015\243" +
    "\016\176\024\261\027\242\030\254\033\256\034\252\035" +
    "\260\036\262\040\200\041\240\042\235\043\247\044\264" +
    "\045\251\046\257\047\233\050\253\051\234\052\255\001" +
    "\001\000\060\007\245\010\241\012\271\015\243\016\176" +
    "\024\261\027\242\030\254\033\256\034\252\035\260\036" +
    "\262\040\200\041\240\042\235\043\247\044\264\045\251" +
    "\046\257\047\233\050\253\051\234\052\255\001\001\000" +
    "\062\007\245\010\241\011\272\012\244\015\243\016\176" +
    "\024\261\027\242\030\254\033\256\034\252\035\260\036" +
    "\262\040\200\041\240\042\235\043\247\044\264\045\251" +
    "\046\257\047\233\050\253\051\234\052\255\001\001\000" +
    "\002\001\001\000\060\007\245\010\241\012\271\015\243" +
    "\016\176\024\261\027\242\030\254\033\256\034\252\035" +
    "\260\036\262\040\200\041\240\042\235\043\247\044\264" +
    "\045\251\046\257\047\233\050\253\051\234\052\255\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\016\176" +
    "\040\200\051\312\001\001\000\010\016\176\040\200\051" +
    "\310\001\001\000\010\016\176\040\200\051\306\001\001" +
    "\000\010\016\176\040\200\051\304\001\001\000\010\016" +
    "\176\040\200\051\302\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\016\176\040\200\051\316\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\040\010\015\016" +
    "\323\022\325\023\322\024\036\031\324\032\326\033\032" +
    "\034\027\035\033\036\035\041\014\042\013\050\026\052" +
    "\030\001\001\000\002\001\001\000\002\001\001\000\036" +
    "\010\015\016\323\022\325\023\322\024\036\032\332\033" +
    "\032\034\027\035\033\036\035\041\014\042\013\050\026" +
    "\052\030\001\001\000\002\001\001\000\002\001\001\000" +
    "\062\007\245\010\241\011\330\012\244\015\243\016\176" +
    "\024\261\027\242\030\254\033\256\034\252\035\260\036" +
    "\262\040\200\041\240\042\235\043\247\044\264\045\251" +
    "\046\257\047\233\050\253\051\234\052\255\001\001\000" +
    "\060\007\245\010\241\012\271\015\243\016\176\024\261" +
    "\027\242\030\254\033\256\034\252\035\260\036\262\040" +
    "\200\041\240\042\235\043\247\044\264\045\251\046\257" +
    "\047\233\050\253\051\234\052\255\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$HaskellSintactico$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$HaskellSintactico$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$HaskellSintactico$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


 
    public static LinkedList<Analizadores.Errores> Err = new LinkedList<Analizadores.Errores>();
    public static Nodo raiz;

    public void syntax_error(Symbol s)
    {
        String texto = s.value.toString();
        int columna = s.right+1;
        int fila = (s.left+2);
        
        System.out.println("Error Sintactico Recuperado: "+texto+" Fila: "+fila+" Columna: " +columna);
        Analizadores.Errores err = new Analizadores.Errores("Sintactico: ","No se esperaba: ",texto,fila,columna);
        Err.add(err);
        //Errores.ErrorSemantico("Sintactico: No se esperaba "+texto, 0, 0);

    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        String texto = s.value.toString();
        int columna = s.right+1;
        int fila = (s.left+2);
        
        System.out.println("Error Sintactico Modo Panico: "+texto+" Fila: "+fila+" Columna: " +columna);
        Analizadores.Errores err = new Analizadores.Errores("Sintactico: ","No se esperaba: ",texto,fila,columna);
        Err.add(err);
        Errores.ErrorSemantico("Sintactico: No se esperaba "+texto, fila, columna);
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$HaskellSintactico$actions {


    

  private final HaskellSintactico parser;

  /** Constructor */
  CUP$HaskellSintactico$actions(HaskellSintactico parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$HaskellSintactico$do_action_part00000000(
    int                        CUP$HaskellSintactico$act_num,
    java_cup.runtime.lr_parser CUP$HaskellSintactico$parser,
    java.util.Stack            CUP$HaskellSintactico$stack,
    int                        CUP$HaskellSintactico$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$HaskellSintactico$result;

      /* select the action based on the action number */
      switch (CUP$HaskellSintactico$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= INICIO EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo start_val = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		RESULT = start_val;
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$HaskellSintactico$parser.done_parsing();
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Nodo RESULT =null;

                System.out.println("Empezo Haskell\n");
           
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("NT$0",41, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // INICIO ::= NT$0 FUNCION 
            {
              Nodo RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Nodo) ((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                System.out.println("Finalizo Haskell\n");
                parser.raiz = nodo;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("INICIO",0, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // FUNCION ::= FUNCION L_FUNCION 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		int funleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int funright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo fun = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                nodo.Hijo(fun);
                RESULT = nodo;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCION",3, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // FUNCION ::= L_FUNCION 
            {
              Nodo RESULT =null;
		int funleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int funright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo fun = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                Nodo nuevo = new Nodo("CuerpoArchivo");
                nuevo.Hijo(fun);
                RESULT = nuevo;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCION",3, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // L_FUNCION ::= id P igual CUERPO fin 
            {
              Nodo RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-4)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-4)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-4)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).right;
		Nodo param = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).value;
		int corpoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int corporight = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo corpo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
                    Nodo nuevo = new Nodo("Funcion");
                    Nodo nombre = new Nodo(name);
                    Nodo cuerpo = new Nodo("CuerpoFuncion");
                    cuerpo.Hijo(corpo);
                    nuevo.Hijo(nombre);
                    if(param!=null){
                        nuevo.Hijo(param);
                    }
                    nuevo.Hijo(cuerpo);
                    RESULT = nuevo;
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_FUNCION",4, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-4)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // P ::= PARAMETROS 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		RESULT = nodo;
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("P",10, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // P ::= 
            {
              Nodo RESULT =null;

              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("P",10, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // PARAMETROS ::= PARAMETROS coma L_PARAM 
            {
              Nodo RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo param = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo p = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  
                    param.Hijo(p); 
                    RESULT= param;
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("PARAMETROS",2, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // PARAMETROS ::= L_PARAM 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                    Nodo nuevo = new Nodo("Parametros");
                    nuevo.Hijo(exp);
                    RESULT = nuevo;
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("PARAMETROS",2, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // L_PARAM ::= EXP 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                RESULT = exp;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_PARAM",1, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // L_PARAM ::= LISTA 
            {
              Nodo RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo lista = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = lista; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_PARAM",1, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // CUERPO ::= CUERPO L_CUERPO 
            {
              Nodo RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo sent = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo cuerpo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                sent.Hijo(cuerpo);
                RESULT=sent;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("CUERPO",7, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // CUERPO ::= L_CUERPO 
            {
              Nodo RESULT =null;
		int sentencialeft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int sentenciaright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo sentencia = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                Nodo nuevo = new Nodo("Sentencias");
                nuevo.Hijo(sentencia);
                RESULT = nuevo;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("CUERPO",7, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // L_CUERPO ::= IF 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_CUERPO",8, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // L_CUERPO ::= CASE 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_CUERPO",8, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // L_CUERPO ::= FUNCIONES_PROPIAS 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_CUERPO",8, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // IF ::= si EXP entonces CUERPO sino CUERPO fin 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-5)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-5)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-5)).value;
		int corpoifleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).left;
		int corpoifright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).right;
		Nodo corpoif = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).value;
		int corposinoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int corposinoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo corposino = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("If");
            Nodo novo = new Nodo("Else");
            Nodo cuerpo = new Nodo("CuerpoIf");
            Nodo cuerpo2 = new Nodo("CuerpoSino");
            Nodo cond = new Nodo("Exp");
            cond.Hijo(exp);
            cuerpo.Hijo(corpoif);
            cuerpo2.Hijo(corposino);
            nuevo.Hijo(cond);
            nuevo.Hijo(cuerpo);
            nuevo.Hijo(cuerpo2);
            RESULT = nuevo;            
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("IF",21, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-6)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // CASE ::= caso EXP_CASO CASOS fin 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int corpoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int corporight = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo corpo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Case");
            nuevo.Hijo(exp);
            nuevo.Hijo(corpo);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("CASE",22, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // CASOS ::= CASOS L_CASOS 
            {
              Nodo RESULT =null;
		int casoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int casoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo caso = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            caso.Hijo(exp);
            RESULT = caso;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("CASOS",23, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // CASOS ::= L_CASOS 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("Lista_Casos");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("CASOS",23, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // L_CASOS ::= EXP_CASO dospuntos CUERPO puntoycoma 
            {
              Nodo RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).left;
		int vright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).right;
		Nodo v = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).value;
		int corpoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int corporight = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo corpo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
                Nodo nuevo = new Nodo("Caso");
                nuevo.Hijo(v);
                nuevo.Hijo(corpo);
                RESULT = nuevo;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_CASOS",24, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // EXP_CASO ::= EXP 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("Exp");
                    nuevo.Hijo(exp);
                    RESULT = nuevo;
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_CASO",16, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // EXP_CASO ::= LISTA 
            {
              Nodo RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo lista = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		RESULT = lista;
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_CASO",16, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // FUNCIONES_PROPIAS ::= DECLARA_LISTA 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // FUNCIONES_PROPIAS ::= CALCULAR 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // FUNCIONES_PROPIAS ::= SUCC 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // FUNCIONES_PROPIAS ::= DECC 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // FUNCIONES_PROPIAS ::= MIN 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // FUNCIONES_PROPIAS ::= MAX 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // FUNCIONES_PROPIAS ::= SUM 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // FUNCIONES_PROPIAS ::= PRODUCT 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // FUNCIONES_PROPIAS ::= REVERS 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // FUNCIONES_PROPIAS ::= IMPR 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // FUNCIONES_PROPIAS ::= PAR 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // FUNCIONES_PROPIAS ::= ASC 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // FUNCIONES_PROPIAS ::= DESC 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // FUNCIONES_PROPIAS ::= LENGTH 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // FUNCIONES_PROPIAS ::= CONCATENA 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // FUNCIONES_PROPIAS ::= INDICE 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // FUNCIONES_PROPIAS ::= LLAMA_FUNCION 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("FUNCIONES_PROPIAS",5, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // DECLARA_LISTA ::= dolar let id igual CONCATENA dolar 
            {
              Nodo RESULT =null;
		int nombreleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).left;
		int nombreright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).right;
		Object nombre = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
                    Nodo nuevo = new Nodo("D_Lista");
                    Nodo name = new Nodo(nombre);
                    nuevo.Hijo(name);
                    nuevo.Hijo(exp);
                    RESULT = nuevo;
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("DECLARA_LISTA",11, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-5)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // CALCULAR ::= dolar calcular EXP dolar 
            {
              Nodo RESULT =null;
		int calculaleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int calcularight = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Object calcula = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
                Nodo cal = new Nodo("Calcular");
                Nodo expresion = new Nodo("Exp");
                expresion.Hijo(exp);
                cal.Hijo(expresion);
                RESULT = cal;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("CALCULAR",18, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // SUCC ::= dolar succ EXP dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Succ");
            Nodo lista = new Nodo("Exp");
            lista.Hijo(exp);
            nuevo.Hijo(lista);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("SUCC",25, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // DECC ::= dolar decc EXP dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Decc");
            Nodo lista = new Nodo("Exp");
            lista.Hijo(exp);
            nuevo.Hijo(lista);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("DECC",26, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // MIN ::= dolar min M dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Min");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("MIN",27, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // MAX ::= dolar max M dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Max");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("MAX",28, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // M ::= id 
            {
              Nodo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 Nodo nuevo = new Nodo("id");
           Nodo i = new Nodo(id); 
           nuevo.Hijo(i);
           RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("M",29, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // M ::= LISTA 
            {
              Nodo RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo lista = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = lista; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("M",29, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // SUM ::= dolar sum CONCATENA dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Sum");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("SUM",31, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // PRODUCT ::= dolar product CONCATENA dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Product");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("PRODUCT",32, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // REVERS ::= dolar revers CONCATENA dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Revers");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("REVERS",33, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // IMPR ::= dolar impr CONCATENA dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Impr");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("IMPR",34, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // PAR ::= dolar par CONCATENA dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Par");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("PAR",35, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // ASC ::= dolar asc CONCATENA dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Asc");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("ASC",36, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // DESC ::= dolar desc CONCATENA dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Desc");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("DESC",37, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // LENGTH ::= dolar tam CONCATENA dolar 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            Nodo nuevo = new Nodo("Length");
            nuevo.Hijo(exp);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("LENGTH",38, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // CONCATENA ::= CONCATENA concatena C_L 
            {
              Nodo RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo c = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo l = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 
                c.Hijo(l);  
                RESULT = c; 
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("CONCATENA",39, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // CONCATENA ::= C_L 
            {
              Nodo RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo l = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                Nodo lista = new Nodo("Concatena");
                lista.Hijo(l);
                RESULT = lista;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("CONCATENA",39, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // C_L ::= LISTA 
            {
              Nodo RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo lista = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		RESULT = lista;
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("C_L",30, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // C_L ::= id 
            {
              Nodo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("id"); 
            Nodo i = new Nodo(id);
            nuevo.Hijo(i);
            RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("C_L",30, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // C_L ::= cadena 
            {
              Nodo RESULT =null;
		int cadleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int cadright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object cad = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("cadena"); 
            Nodo n = new Nodo(cad.toString().replace("\"", ""));
            nuevo.Hijo(n); RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("C_L",30, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // INDICE ::= id indice EXP_INDICE L_INDICE 
            {
              Nodo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		int otroleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int otroright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo otro = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                Nodo nuevo = new Nodo("Indice");
                Nodo nombre = new Nodo(id);
                Nodo e = new Nodo("Exp");
                e.Hijo(exp);
                nuevo.Hijo(nombre);
                nuevo.Hijo(e);
                if (otro!=null){
                    nuevo.Hijo(otro);
                }
                RESULT = nuevo;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("INDICE",40, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-3)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // L_INDICE ::= indice EXP_INDICE 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                Nodo nuevo = new Nodo("Exp");
                nuevo.Hijo(exp);
                RESULT = nuevo;
            
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_INDICE",20, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // L_INDICE ::= 
            {
              Nodo RESULT =null;

              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("L_INDICE",20, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // EXP_INDICE ::= EXP_INDICE mas EXP_INDICE 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("+");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // EXP_INDICE ::= EXP_INDICE menos EXP_INDICE 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("-");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // EXP_INDICE ::= EXP_INDICE por EXP_INDICE 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("*");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // EXP_INDICE ::= EXP_INDICE div EXP_INDICE 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("/");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // EXP_INDICE ::= EXP_INDICE residuo EXP_INDICE 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("mod");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // EXP_INDICE ::= EXP_INDICE sqrt EXP_INDICE 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("sqrt");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // EXP_INDICE ::= EXP_INDICE pot EXP_INDICE 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("pot");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // EXP_INDICE ::= SUM 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // EXP_INDICE ::= PRODUCT 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // EXP_INDICE ::= LENGTH 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // EXP_INDICE ::= menos EXP_INDICE 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("Unario");
            nuevo.Hijo(nodo);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // EXP_INDICE ::= parenAbre EXP_INDICE parenCierra 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // EXP_INDICE ::= CALCULAR 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // EXP_INDICE ::= LLAMA_FUNCION 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // EXP_INDICE ::= SUCC 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // EXP_INDICE ::= DECC 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // EXP_INDICE ::= MIN 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // EXP_INDICE ::= MAX 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // EXP_INDICE ::= entero 
            {
              Nodo RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object num = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("numero"); 
            Nodo n = new Nodo(num);
            nuevo.Hijo(n); 
            RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // EXP_INDICE ::= cadena 
            {
              Nodo RESULT =null;
		int cadleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int cadright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object cad = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("cadena"); 
            Nodo n = new Nodo(cad.toString().replace("\"", ""));
            nuevo.Hijo(n); 
            RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // EXP_INDICE ::= caracter 
            {
              Nodo RESULT =null;
		int letraleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int letraright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object letra = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("caracter"); 
            Nodo l = new Nodo(letra);
            nuevo.Hijo(l); 
            RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // EXP_INDICE ::= id 
            {
              Nodo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("id"); 
            Nodo i = new Nodo(id);
            nuevo.Hijo(i);
            RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP_INDICE",19, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // LISTA ::= corAbre LISTAS corCierra 
            {
              Nodo RESULT =null;
		int listasleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int listasright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo listas = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		 RESULT = listas; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("LISTA",12, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // LISTAS ::= EXPRESIONES 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		RESULT = exp; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("LISTAS",13, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // LISTAS ::= MAS_CORCH 
            {
              Nodo RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo lista = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		RESULT = lista; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("LISTAS",13, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // EXPRESIONES ::= EXPRESIONES coma EXP 
            {
              Nodo RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo lista = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  
                    lista.Hijo(exp); 
                    RESULT = lista; 
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXPRESIONES",15, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // EXPRESIONES ::= EXP 
            {
              Nodo RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo exp = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 
                    Nodo lista = new Nodo("Lista");
                    lista.Hijo(exp); 
                    RESULT = lista; 
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXPRESIONES",15, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // MAS_CORCH ::= MAS_CORCH coma DIM 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int dimleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int dimright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo dim = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
                    nodo.Hijo(dim);
                    RESULT = nodo;
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("MAS_CORCH",14, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // MAS_CORCH ::= DIM 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		Nodo nivel = new Nodo("2Niveles");
                    nivel.Hijo(nodo);
                    RESULT = nivel;
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("MAS_CORCH",14, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // DIM ::= corAbre EXPRESIONES corCierra 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		
            
            RESULT =nodo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("DIM",9, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // EXP ::= EXP mas EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("+");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // EXP ::= EXP menos EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("-");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // EXP ::= EXP por EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("*");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // EXP ::= EXP div EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("/");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // EXP ::= EXP residuo EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("mod");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // EXP ::= EXP sqrt EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("sqrt");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // EXP ::= EXP pot EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("pot");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // EXP ::= EXP or EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("||");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // EXP ::= EXP and EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("&&");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // EXP ::= EXP menorq EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("<");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // EXP ::= EXP mayorq EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo(">");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // EXP ::= EXP menorigualq EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("<=");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // EXP ::= EXP mayorigualq EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo(">=");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // EXP ::= EXP igualigual EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("==");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // EXP ::= EXP diferente EXP 
            {
              Nodo RESULT =null;
		int jleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo j = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo m = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("!=");
            nuevo.Hijo(j);
            nuevo.Hijo(m);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // EXP ::= SUM 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // EXP ::= PRODUCT 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // EXP ::= LENGTH 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // EXP ::= menos EXP 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		
            Nodo nuevo = new Nodo("Unario");
            nuevo.Hijo(nodo);
            RESULT = nuevo;
        
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // EXP ::= parenAbre EXP parenCierra 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-1)).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // EXP ::= CALCULAR 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // EXP ::= LLAMA_FUNCION 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // EXP ::= INDICE 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // EXP ::= SUCC 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // EXP ::= DECC 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // EXP ::= MIN 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // EXP ::= MAX 
            {
              Nodo RESULT =null;
		int nodoleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int nodoright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Nodo nodo = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		 RESULT = nodo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // EXP ::= entero 
            {
              Nodo RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object num = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("numero"); 
            Nodo n = new Nodo(num);
            nuevo.Hijo(n); 
            RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // EXP ::= cadena 
            {
              Nodo RESULT =null;
		int cadleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int cadright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object cad = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("cadena"); 
            Nodo n = new Nodo(cad.toString().replace("\"", ""));
            nuevo.Hijo(n); RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // EXP ::= caracter 
            {
              Nodo RESULT =null;
		int letraleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int letraright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object letra = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("caracter"); 
            Nodo l = new Nodo(letra);
            nuevo.Hijo(l); 
            RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // EXP ::= id 
            {
              Nodo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.peek()).value;
		  Nodo nuevo = new Nodo("id"); 
            Nodo i = new Nodo(id);
            nuevo.Hijo(i);
            RESULT = nuevo; 
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("EXP",17, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // LLAMA_FUNCION ::= dolar id llaveAbre P llaveCierra dolar 
            {
              Nodo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-4)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-4)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).right;
		Nodo param = (Nodo)((java_cup.runtime.Symbol) CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-2)).value;
		
                    Nodo nuevo = new Nodo("LlamaFunc");
                    Nodo nombre = new Nodo(id);
                    nuevo.Hijo(nombre);
                    nuevo.Hijo(param);
                    RESULT = nuevo;
                
              CUP$HaskellSintactico$result = parser.getSymbolFactory().newSymbol("LLAMA_FUNCION",6, ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.elementAt(CUP$HaskellSintactico$top-5)), ((java_cup.runtime.Symbol)CUP$HaskellSintactico$stack.peek()), RESULT);
            }
          return CUP$HaskellSintactico$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$HaskellSintactico$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$HaskellSintactico$do_action(
    int                        CUP$HaskellSintactico$act_num,
    java_cup.runtime.lr_parser CUP$HaskellSintactico$parser,
    java.util.Stack            CUP$HaskellSintactico$stack,
    int                        CUP$HaskellSintactico$top)
    throws java.lang.Exception
    {
              return CUP$HaskellSintactico$do_action_part00000000(
                               CUP$HaskellSintactico$act_num,
                               CUP$HaskellSintactico$parser,
                               CUP$HaskellSintactico$stack,
                               CUP$HaskellSintactico$top);
    }
}

}
